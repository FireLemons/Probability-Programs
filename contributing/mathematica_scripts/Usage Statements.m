(***********************************************************************
This file was generated automatically by the Mathematica front end.
It contains Initialization cells from a Notebook file, which typically
will have the same name as this file except ending in ".nb" instead of
".m".

This file is intended to be loaded into the Mathematica kernel using
the package loading commands Get or Needs.  Doing so is equivalent to
using the Evaluate Initialiation Cells menu command in the front end.

DO NOT EDIT THIS FILE.  This entire file is regenerated automatically 
each time the parent Notebook file is saved in the Mathematica front end.
Any changes you make to this file will be overwritten.
***********************************************************************)

Areabargraph::usage = "Areabargraph[data, xmin, xmax, k] divides the interval [xmin, xmax] on the x-axis into k subintervals of equal length. Then, on each subinterval, a box is erected whose area is equal to the percentage of values in the list data which are in the subinterval. Important note: only data values which fall in the user-defined interval will be included in	the bar graph. If not all data values are included, a warning is displayed.";

Bargraph::usage = "Bargraph[data, xmin, xmax, k] divides the interval [xmin, xmax] on the x-axis into k subintervals of equal length. Then, on each subinterval, a box is erected whose height is equal to the percentage of values in the list data which are in the subinterval. Important note: only data values which fall in the user-defined interval will be included in	the bar graph. If not all data values are included, a warning is displayed.";

Bin::usage = "Bin[n, p, k] returns the probability of exactly k successes in n Bernoulli trials with probability of success p on each experiment.";

ContinuousMean::usage = "ContinuousMean[f, a, b] calculates the mean of density function f on [a,b].";

ContinuousVariance::usage = "ContinuousVariance[f, a, b] calculates the variance of density function f on [a, b].";

DiscreteMean::usage = "DiscreteMean[distributionlist] returns the mean of the distribution given in distributionlist.";

DiscreteVariance::usage = "DiscreteVariance[distributionlist] returns the variance of the distribution given in distributionlist.";

LabelMatrix::usage = "LabelMatrix[M, rowlabels, columnlabels] labels M's rows and columns by creating a new matrix, M2, which contains M's labels. Since M2's rows and columns contain these labels, M2  should not be used in performing computations with M; it should be used only  for displaying M.";

NormalArea::usage = "NormalArea[x, mu, sigma] returns the area under the standard normal density curve on [a, b].";

NormalDensity::usage = "NormalDensity[x, mu, sigma] returns the normal density function with mean mu and standard deviation sigma.";

SimulateDiscreteVariable::usage = "SimulateDiscreteVariable[plist] simulates an experiment which has outcomes x_1, x_2, ..., x_(Length[plist]) with probabilties plist[[1]], plist[[2]], ..., plist[[Length[plist]]], respectively. The program returns i, where x_i is the outcome of the experiment.";

SpikeData::usage = "SpikeData[data] takes a list of data values representing the outcomes of a series of experiments, and returns the dstribution list representing these outcomes and the fraction of the time they occurred (e.g., their experimental probabilities). The returned list is in a form acceptable as the first parameter being passed to the programs 'Spikegraph[distributionlist, xmin, xmax]' and 'SpikegraphWithDots[distributionlist, xmin, xmax, color, print].' ";

Spikegraph::usage = "Spikegraph[distributionlist, xmin, xmax, print] displays a graph of the distribution of x (where x has the distribution given in distributionlist) by drawing a spike of height p(x) at each x. If print = True, this graph is displayed. Otherwise, the display is (for the time being) supressed. Important note:  only values of x which fall in the user-defined interval [xmin,  xmax] will be included in the graph. If not all values of x are included, and print = True, a warning is displayed.  If print = False, no such warning will be given, even if the graph is later displayed.  ";

SpikegraphWithDots::usage = "SpikegraphWithDots[distributionlist, xmin, xmax, color, print] displays a graph of the distribution of x (where x has the distribution given in distributionlist) by drawing a spike of height p(x) at each x, and topping that spike with a dot of color color. If print = True, this graph is  displayed. Otherwise, the display is (for the time being) supressed. Important note: only values of x which fall in the user-defined interval [xmin, xmax] will be included in the graph. If not all values of x are included, and print = True, a warning is displayed. If print = False, no such warning will be given, even if the graph is later displayed. ";

RandomNumbers::usage = "RandomNumbers[n] displays n random real numbers between 0 and 1.";

CoinTosses::usage = "CoinTosses[n, print] simulates n tosses of a fair coin, and prints the proportion of tosses that come up heads. If print = True, then the outcomes of the tosses (H/T) are also printed.";

DeMere1::usage = "DeMere1[n, print] simulates 4 rolls of a die, and determines whether a six has appeared (a 'success'). It repeats this experiment n times, and prints the number of trials that resulted in a success. It also prints the proportion of trials that resulted in a success. Finally, if print = True, then the rolls are printed out.";

DeMere2::usage = "DeMere2[n, m, print] simulates m rolls of two dice, and determines whether a double 6 has appeared (a 'success'). It repeats this experiment n times, and prints the number of trials that resulted in a success. It also prints the proportion of trials that resulted in a success. Finally, if print = True, then the rolls are printed out.";

HTSimulation::usage = "HTSimulation[n, m, print] simulates an experiment in which a fair coin is tossed m times. The experiment is repeated n times. The program records the 'winnings' in each experiment, where the winnings are defined to be the number of heads minus the number of tails. It also keeps track of the number of times the winnings are 'positive' in the course of an experiment (we count as 'positive' a time at which the winnings are 0 but the previous winnings are positive). The program returns a list whose first element is a list of the winnings in each experiment (winningslist), and whose second element is a list of times in the lead in each experiment (timesinleadlist). If print = True and n = 1, then a graph of the game is displayed. If print = True and n > 1, then spike graphs of the winningslist and timesinleadlist are displayed. ";

HorseRace::usage = "HorseRace[n] simulates n of the horse races described in Chapter 1. The program prints each race winner, and returns a list containing the percentage of times each horse won.";

GeneralSimulation::usage = "GeneralSimulation[n, plist, m, print]simulates m general experiments in which the outcomes 1, 2, ..., n occur with probabilties plist[[1]], plist[[2]], ..., plist[[n]]. The observed frequencies of the outcomes are printed, and if print = True, the outcomes are printed, and spike graphs of the observed data frequencies and plist data frequencies are displayed on the same set of axes (the observed data spikes are topped with blue dots, the plist data spikes with red). Finally, the program returns a list of the n observed frequencies.";

MonteCarlo::usage = "MonteCarlo[n, f, xmin, xmax, ymax] estimates  the area under the input function f[x] and above the interval [xmin, xmax] by choosing n random points in the rectangle above the interval [xmin, xmax] and between the y-values 0 and ymax. The program returns its area estimate,  and also plots the random points and the function f[x] on the interval  [xmin, xmax].";

BuffonsNeedle::usage = "BuffonsNeedle[n, print] simulates the Buffon needle experiment described in the book, dropping n pins on a 10 x 10 grid. The program returns an estimate for Pi, using the book's method. If print = True, a graphical display of the experiment is produced, showing every one-hundredth pin. ";

BertrandsParadox::usage = "BertrandsParadox[n, print] illustrates Bertrand's Paradox by choosing n random chords of a circle three times, each time using a different one of the three coordinatizations described in the book. For each coordinatization, the program prints the proportion of chosen chords with length greater than Sqrt[3] and, if print = True, displays a picture of the experiment, drawing  every one-hundredth chord.";

Darts::usage = "Darts[n, print] simulates n throws of a dart at a circular dartboard of radius 1. The program displays a bar graph in which the area of the i'th bar is equal to the fraction of the total falling in the i'th region. If print = True, then the program returns a list of distances that the dart landed from the center of the board.";

GaltonBoard::usage = "GaltonBoard[n, m, print] simulates n Galton board experiments, with m rows of pins. Each simulation consists of choosing 0 or 1 m times, and summing the chosen numbers. The program then displays an area bar graph of the experiment results. If print = True, a list of all the final positions is returned.  ";

Birthday::usage = "Birthday[rmin, rmax, inc] computes and displays the probabilities that no two people in a group of size r have the same birthday, where r ranges from rmin to rmax by increment inc.";

StirlingApproximations::usage = "StirlingApproximations[nmin, nmax] calculates and displays n!, the Stirling approximation of n!, and the ratio of these two numbers, for every integer n between nmin and nmax.";

FixedPoints::usage = "FixedPoints[n, m, significant] generates n random permutations of the numbers 1, ..., m, and calculates the number of fixed points in each. For each possible number of fixed points the proportion of simulations with that number of fixed points is printed, if that proportion is greater than the significant parameter of the program.";

Records::usage = "Records[num, n] counts the number of  'records,' as defined in the book, in individual random permutations of {1, 2, ..., n}. The number of permutations tested is num. The program returns the average number of records per permutation.   ";

AllPermutations::usage = "AllPermutations[n] returns a list of all the permutations of the set {1, 2, ..., n}.";

BinomialPlot::usage = "For each n in nlist, BinomialPlot[nlist, p] plots a spike graph of the distribution for n Bernoulli trials with probability of success p. These graphs are all plotted on the same set of axes.";

BinomialProbabilities::usage = "BinomialProbabilities[n, p, kmin, kmax, print] returns the sum of the binomial probabilities for k between kmin and kmax.  If print = True, the individual probabilities are printed.";

PowerCurve::usage = "The book defines, given m and n, alpha(p) = Sum[binomial(n, p, k)], k = m, . . ., n. The user enters into PowerCurve nullp (the null hypthesis p-value) and an altp (an alternative hypothesis p, greater than nullp). The program then defines pmin = nullp - Abs[altp - nullp] and pmax = altp + Abs[altp - nullp], and plots alpha(p) on the interval [pmin, pmax] for each value m in mlist, with n equal to the parameter n. The program displays all of these graphs together on a single set of axes, along with a dotted-line box. We ultimately want each of the probabilities of a type 1or type 2 error occurring to be <=  errormax. The box the program draws is such that a value of m satisfies this requirement if and only if  the graph of alpha(p) enters the box from the bottom and leaves from the top (see book for more details).";

AShuffle::usage = "AShuffle[a, deck, print] models an a-shuffle of a deck ordered as in the list deck. (For instance:  if you want to a-shuffle a numerically-ordered deck of length n, enter Table[i, {i, 1, n}] as the deck parameter.) If print = True, then the program displays a list of places the cuts occurred, and a list of the piles into which those cuts divided the original deck. The program returns a list representing the shuffled deck.";

A::usage = "A[n, r] calculates the Eulerian number A(n, r) (i.e., the number of orderings of {1, 2, ...., n} with r falls).";

VariationDistance::usage = "VariationDistance[n, k] calculates the variation distance, v(k), between a process which produces random orderings of n cards,  and the process consisting of one (2^k)-shuffle of those cards.";

VariationList::usage = "For k = 1 to m, VariationList[n, m] calculates and displays the variation distance, v(k), between a process which produces random orderings of n cards,  and the process consisting of one (2^k)-shuffle of those cards. It also provides a plot of the points (k, v(k)) for k = 1 to m.";

BetaDensity::usage = "BetaDensity[alpha, beta, x] gives the beta density function with parameters alpha and beta.";

Bayes::usage = "Bayes[hlist, prior, elist, conditional] takes hlist, a list of an experiment's hypotheses (i.e., the set of all H_i); prior, a list whose i'th entry is the prior probability P(H_i); elist, a list of the experiment's evidence events (i.e., the set of all E_i); and conditional, a matrix whose ij'th entry is the conditional probability P(E_j | H_i). The program returns post, a matrix whose ij'th entry is the posterior probability P(H_j | E_i). The program also prints out post with its rows and columns labeled by the elements of elist and hlist, respectively.";

TwoArm::usage = "TwoArm[n, x, y, s] simulates the two strategies play-the-better-machine and play-the-winner, in connection with the Two-Armed Bandit problem. The variables x and y represent the respective probabilities that machines 1 and 2 pay off a dollar on a single play. If s = 1, the play-the-better-machine strategy is used; otherwise, the play-the-winner strategy is used. The variable n is the number of plays to be simulated. For each play, the program prints out which machine was used, and what the results of the play were (i.e., whether it was won or lost). Further, the program plots the final expermimentally-determined densities for x and y, plotting that of x with a solid line, and that of y with a dotted one.";

GeometricPlot::usage = "GeometricPlot[p, nmax] draws a spike graph of the geometric distribution function with p = p, for n = 1 to nmax.";

Queue::usage = "Queue[lambda, mu, tmax] simulates the queue problem described in the book, for times  t = 0 to tmax, where the interarrival times between successive cutsomers are exponentially distributed with parameter lambda, and the service times for successive customers are exponentially distribued with parameter mu.  The program displays a list plot where the x-axis represents time, and the point f(x) represents the number of customers in line at time x. Actual points are plotted only for integer values of x, but these points are joined with lines to make viewing  the graph easier.";

Craps::usage = "Craps[n] simulates n plays of the game of craps, with a bet of one dollar being made for each game. The average number of winnings per game is printed out.";

Die::usage = "Die[n, s] simulates the following experiment n times: an s-sided die is rolled. If an odd number turns up, an amount equal to that number is won; if an even number turns up, an amount equal to that number is lost. The program displays the frequency and the relative frequency with which each outcome occurs, as well as displaying the average gain over the n trials.";

StockSystem::usage = "StockSystem[n, print] simulates Mr. Ace's playing of the stock market, as described in the book, where he must stop after n days. The program prints out and returns Mr. Ace's net gain after the n days, and plots the points (x, f(x)) for x = 0 to n, where x is the number of the day, and f(x) is the value of V on day x. The points are connected with lines: dotted lines indicate time during which Mr. Ace holds stock under his system; unbroken lines indicate time during which he does not hold stock.";

ConsolidateList::usage = "ConsolidateList[inputlist] takes as its input a list of ordered pairs, which is assumed to be sorted in lexicographic order, and produces a list of ordered pairs in which each pair's second element is the sum of all second elements of inputlist ordered pairs  with the same first coordinate.";

Convolution::usage = "Convolution[distributionlist1, distributionlist2] returns the convolution of the two discrete distributions given in distributionlist1 and distributionlist2.";

NFoldConvolution::usage = "NFoldConvolution[distributionlist, n] returns the n-fold convolution distribution of the distribution given in distributionlist.";

DieTest::usage = "DieTest[numbtrials, numbrolls, plist] performs an experiment in which a die is rolled numrolls times, and computes Z, as defined in the text. The die's faces are numbered 1 through 6, and the probability of  face i coming up is given by plist[[i]]. If numbtrials = 1, the program prints out Z, and its corresponding p-value with 5 degrees of freedom . If numbtrials > 1, the experiment is carried out numbtrials times, and three graphs are output. The first is an area bargraph of the Z values for each experiment. The second is the corresponding chi-square density. The third overlays the chi-square density on the bargraph.  ";

Law::usage = "For n = nmin to nmax, in steps of size inc, Law[nmin, nmax, inc, p, e] computes and displays (1) the exact probability P(|A_n - p| >= e), where A_n is the average outcome of n Bernoulli trials with probability p of success, and (2) the Chebyshev estimate p(1-p)/(n(e^2)) for this probability.";

LawContinuous::usage = "For n = nmin to nmax, in steps of size inc, LawContinuous[nmin, nmax, inc, e] computes and displays (1) the exact probability P(|S_n/n| >= e), where S_n is a sum of n standard normally-distributed random variables, and (2) the Chebyshev estimate 1/n*(e^2) for this probability.";

CLTBernoulliPlot::usage = "CLTBernoulliPlot[n, p] displays the standard normal distribution curve, and a spike graph of the standardized binomial probabilities binomial(i, p, k), for i = 1 to n. It displays these two graphs on the interval [-4, 4], on a single set of axes.";

CLTBernoulliLocal::usage = "CLTBernoulliLocal[n, p, k] computes and displays the exact calculation of binomial(n, p, k) and the normal approximation of the same.";

CLTBernoulliGlobal::usage = "CLTBernoulliGlobal[n, p, kmin, kmax, half] uses the normal approximation to approximate the probability that S_n, a sum of n Bernoulli trials with probability p of success for each trial, lies in [kmin, kmax]. If half = True, the program includes the 1/2 correction; otherwise, it doesn't.";

LondonBombs::usage = "LondonBombs[numbombs, numsquares, xmin, xmax] simulates the London bombing situation described in the book, with a district of numsquares squares, and with numbombs bombs being  dropped. For integers x in [xmin, xmax], it draws spike graphs of (1) the observed probability of x bombs falling in a single square, and (2) this same probability approximated using the Poisson density with m = numbombs * (1/numsquares). These spike graphs are displayed on the same set of axes, with the observed probability spikes topped with blue dots, and the approximated probability spikes topped with red.";

CLTIndTrialsPlot::usage = "CLTIndTrialsPlot[n, distributionlist] displays the standard normal distribution curve, and a scaled  spike graph of the standardizations of the probabilities P(S_n = j), where S_n is a sum of n independent variables with common distribution given in distributionlist. The program displays these two graphs on the interval [-4, 4], on a single set of axes.";

CLTIndTrialsLocal::usage = "CLTIndTrialsLocal[n, distributionlist, k] computes and displays the exact calculation of P(S_n = k) and the normal approximation of the same, where S_n is a sum of n independent variables with common distribution given in distributionlist.";

CLTIndTrialsGlobal::usage = "CLTIndTrialsGlobal[n, distributionlist, kmin, kmax] uses the normal approximation to approximate the probability that S_n, a sum of n independent trials with common distribution given in distributionlist, lies in [kmin, kmax]. If half = True, the program includes the 1/2 correction; otherwise, it doesn't.";

MakeDistribution::usage = "MakeDistribution[a, b] returns a distribution list with outcome values are integers in [a, b]";

CLTGeneral::usage = "CLTGeneral[n, a, b] generates n random discrete distributions on subsets of [a, b], and convolutes them to find the distribution of S_n, the sum of n experiments governed by these distributions. Now, the CLT asserts that the distribution of S_n*, the standardized version of S_n, approaches the standard normal as n approaches infinity. The program shows this by displaying a spike graph of S_n*, along with a plot of the standard normal density curve, on the interval [-4, 4].";

Branch::usage = "Given that a parent will produce at most Length[plist] offspring, and will produce i offspring with probability plist[[i]], Branch[gmax, plist] computes and displays the probabilities that a branching process designated by this information will die out by generation g, for g = 1 to gmax.";

BranchingSimulation::usage = "BranchingSimulation[n, gmax, plist, changepoint] simulates the branching process designated by plist, until generation gmax. The program does n such simulations, and plots the branching processes with the x-axis indicating number of generations, and the lines y = f(x) indicating the sizes of the generations at time x.";

AbsorbingChain::usage = "AbsorbingChain[P, stateslist, print] takes P, a Markov chain transition matrix and stateslist, the list of possible states in the Markov chain, and finds and returns the matrices Q, R, N, B, and vector t, as defined in the book. If print = True, then the program also displays these matrices and vector, with rows and columns labeled.";

SimulateChain::usage = "SimulateChain[n, P, stateslist, startstate, print] simulates n steps of a Markov chain with transition matrix P and possible states in stateslist, that begins in state startstate. For each state, the program prints out the number of times that state was reached, and the fraction of the time this occurred. The program returns a list whose i'th element is the fraction of the time state stateslist[[i]] was reached. If print = True, the program also prints out each state as it is reached.";

FixedVector::usage = "FixedVector[P, stateslist, print] returns the fixed vector w for an ergodic Markov chain with transition matrix P and possible states in stateslist. If print = True, the program prints out P and w.";

ErgodicChain::usage = "ErgodicChain[P, stateslist, print] returns a list consisting of the mean recurrence times, and mean first passage matrix, for the ergodic chain with transition matrix P and possible states in statelist. If print = True, the program displays P, along with the chain's fixed vector w,  list of mean recurrence times r, and mean first passage matrix M.";

EhrenfestUrn::usage = "EhrenfestUrn[seconds, balls] simulates the Ehrenfest model for gas diffusion by simulating the urn-ball experiment described in the book, with the number of balls = balls, and the number of time units being tested = seconds. The program displays a plot of the experiment, with  the x-axis showing time and the graph y = f(x) showing how many balls are in the first urn at each second x. (Note: the program actually plots points only for integer values of x, since the distribution of f(x) is discrete; however, for the sake of aesthetics, the computer joins these points with lines.)";